---
title: 121. 买卖股票的最佳时机
difficulty: 简单
related: 数组|动态规划
---

## 题目

给定一个数组，它的第`i`个元素是一支给定股票第`i`天的价格。

如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。

注意你不能在买入股票前卖出股票。

## 示例1

**输入：** [7,1,5,3,6,4]

**输出：** 5

**解释：** 在第`2`天（股票价格 = 1）的时候买入，在第`5`天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。

## 示例2

**输入：** [7,6,4,3,1]

**输出：** 0

## 解析

### 思路1（暴力法）

这道题的思路其实比较简单，按照常规思路的想法，可以分成两步：

1. 假设第`i`天买入，找出之后哪天卖出的利润最大。而要解决这个问题，无非就是找数组中`i+1`到`最后一位`的最大值，如果这个最大值都无法盈利，则利润为0。
2. 遍历整个数组，循环重复第一步。

根据对上述两步的描述，查找最大值的时间复杂度是`O(n)`，遍历的时间复杂度是`O(n)`，所以整体的时间复杂度是`O(n^2)`。

不过很显然，这种暴力的方法效率并不高，因此我们可以利用进行改进。

### 思路2（动态规划）

对于查找数组中`i+1`到`最后一位`的最大值这一步骤，我们可以用动态规划的思想，一次性计算出第`i`天之后的最大值，即：

`i`从`n`到`0`递减，`dp[i] = max(dp[i + 1], prices[i])`，时间复杂度是`O(n)`。

根据这个`dp`表，我们再对`prices`数组进行遍历计算最大利润的时候，时间复杂度仍是`O(n)`。因此，总的时间复杂度就降到了`O(2n)`，由于常数项可以省略，所以最终时间复杂度就是`O(n)`。

## 代码

```js
/**
 * @param {number[]} prices
 * @return {number}
 */
var maxProfit = function(prices) {
  
  const dp = [];
  for(let i = prices.length - 1; i >= 0; i--) {
    if(i === prices.length - 1) {
      dp[i] = prices[i];
    } else {
      dp[i] = Math.max(dp[i + 1], prices[i]);
    }
  }

  let ans = 0;
  for(let i = 0; i < dp.length - 1; i++) {
    if(prices[i] < dp[i + 1]) {
      ans = Math.max(ans, dp[i + 1] - prices[i]);
    }
  }

  return ans;
};

// for test

[
  [7,1,5,3,6,4],
  [7,6,4,3,1]
].forEach(prices => {
  console.log(maxProfit(prices));
});
```
